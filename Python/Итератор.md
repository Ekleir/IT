Чтобы по последовательности можно было итерироваться её необходимо превратить в итератор с помощью __iter()__
![[Pasted image 20230705185644.png]]

У всех итераторов,  есть метод **__next__**. Именно его код обеспечивает выдачу очередного элемента.
Когда итератор выдал все свои значения, то очередной вызов **__next__**() должен возбуждать исключение _StopIteration_


Задача метода `__iter__` – "превращать" итерируемый объект(последовательность) в итератор. Если в цикл `for` передается уже итератор, то метод `__iter__()` этого объекта должен возвращать сам объект:

Метод `for` в Python фактически использует методы `__iter__()` и `__next__()` итератора, чтобы выполнить итерацию по элементам. Соответственно для поддержания совместимости необходимо определить метод `__iter__` в итерируемых объектах.

Если нам необходимо реализовать возможность итерации по классу, то в нём необходимо прописать метод работы __iter()__, он должен вернуть объект-итератор. Так мы можем добиться больше гибкости, итерируясь по классу, а не по какому-то полю в этом классе.
![[Pasted image 20230705194902.png]]




