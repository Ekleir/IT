Чтобы по последовательности можно было итерироваться её необходимо превратить в итератор с помощью __iter()__
![[Pasted image 20230705185644.png]]

У всех итераторов,  есть метод **__next__**. Именно его код обеспечивает выдачу очередного элемента.
Когда итератор выдал все свои значения, то очередной вызов **__next__**() должен возбуждать исключение _StopIteration_


Задача метода `__iter__` – "превращать" итерируемый объект(последовательность) в итератор. Если в цикл `for` передается уже итератор, то метод `__iter__()` этого объекта должен возвращать сам объект:

Метод `for` в Python фактически использует методы `__iter__()` и `__next__()` итератора, чтобы выполнить итерацию по элементам. Соответственно для поддержания совместимости необходимо определить метод `__iter__` в итерируемых объектах.

Если нам необходимо реализовать возможность итерации по классу, то в нём необходимо прописать метод работы __iter()__, он _должен вернуть объект-итератор_. Так мы можем добиться больше гибкости, итерируясь по классу, а не по какому-то полю в этом классе.
![[Pasted image 20230705194902.png]]

Для реализации своей логики итерации по классу необходимо создать нужный для нас метод **__next__** с обязательным условием выхода при __StopIteration__
![[Pasted image 20230706190708.png]]
В _итерируемом_ классе так же должен быть метод **__iter__**! т.к. именно этот метод сообщает при обращении, что по объекту можно итерироваться.
![[Pasted image 20230706191057.png]]

Целиком:
![[Pasted image 20230706192927.png]]


