О - принятое обозначение концепции Big(O)
N-формула, описывающее поведение алгоритма

Бывают также small(O), theta, omega
Big(O) показывает как будет меняться производительность в зависимости от возрастания входящих данных(по памяти или производительности).

![[Pasted image 20230611202742.png]]
Сложность алгоритмов обычно оценивают по времени выполнения или по используемой памяти.

### O(n) — линейная сложность
Такой сложностью обладает, алгоритм поиска наибольшего элемента в не отсортированном массиве. придётся пройтись по всем `n` элементам массива, чтобы понять, какой из них максимальный.

### O(log n) — логарифмическая сложность
бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам. Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину. И так будем продолжать делить пополам, в итоге проверим `log n` элементов.

### O(1) - постоянная сложность.
Время выполнения или использование ресурсов алгоритма не зависит от размера входных данных. Например, доступ к элементу в массиве по индексу.

### O(n2) — квадратичная сложность
Такую сложность имеет, алгоритм сортировки вставками. В канонической реализации он представляет из себя два вложенных цикла: один, чтобы проходить по всему массиву, а второй, чтобы находить место очередному элементу в уже отсортированной части. Таким образом, количество операций будет зависеть от размера массива как `n * n`, т. е. `n2`.

Многие алгоритмы предлагают выбор между объёмом памяти и скоростью. Задачу можно решить быстро, использую большой объём памяти, или медленнее, занимая меньший объём.  
Типичным примером в данном случае служит алгоритм поиска кратчайшего пути.




![[Pasted image 20230611190640.png]]
в первом случае рекурсия вызывает себя N раз, чем больше N, тем больше вызывается, линейная сложность. во втором случае 2я функция не влияет на скорость, выполняется 1 раз,ее можно отбросить, а вот первая функция выполняется n раз, зависимость будет тоже линейной.
![[Pasted image 20230611191017.png]]
![[Pasted image 20230611191200.png]]
![[Pasted image 20230611191425.png]]
Нужно отбросить значение, которое значительно меньше другого(_В два раза!_)
![[Pasted image 20230611191711.png]]

![[Pasted image 20230611191949.png]]
![[Pasted image 20230611192032.png]]
![[Pasted image 20230611192108.png]]


![[Pasted image 20230611192231.png]]
![[Pasted image 20230611192309.png]]
![[Pasted image 20230611192545.png]]
![[Pasted image 20230611192654.png]]
![[Pasted image 20230611192741.png]]
![[Pasted image 20230611192816.png]]

Сложна!
![[Pasted image 20230611192958.png]]
![[Pasted image 20230611193042.png]]

![[Pasted image 20230611204557.png]]