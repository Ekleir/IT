Это когда функция вызывает сама себя.
В рекурсии обязательно должно быть задано условие выхода
С каждым рекурсивным вызовом мы должны приближаться к условиям выхода из функции

- Сначала происходит раскрутка рекурсии- в _стек_ добавляется 1 кадр за каждое выполнение функции, но действий никаких не происходит, только добавление, если не выполнено условие выхода или не заполниться стек.
- Когда функция доходит до границы выхода начинается её скрутка- из стека удаляется по одному кадру, записывая результат в вышестоящую функцию, до получения финального результата.

![[Pasted image 20230612181555.png]]

__Головная рекурсия__
Сначала отрабатывает рекурсивный цикл до конца, а потом начинает выполняться логика функции.
Таким образом вызовы накапливаются в стеке вызовов до условий выхода и отработка функции начнётся с конца, до первого вызова функции.

__Хвостовая рекурсия__
Сначала выполняется логика, потом происходит вызов функции.
Т.е. результат записывается в промежуточную переменную и далее вызывается функция, потом полученное значение добавляется в промежуточный результат и так до конечного условия. В таком случае в конце рекурсивного вызова промежуточная функция будет конечным результатом.

__Проблемы рекурсии__
- нехватка места на стеке
- слишком большое время выполнения

Улучшить производительность можно с помощью методов:
![[Pasted image 20230612190716.png]]
__Мемоизация__
когда при определённых входных условиях промежуточный результат выполнения функции сохраняется и в следующий раз при таких же входных данных не вычисляется, а берётся из кеша. 

__Табуляция__
Сначала в кеше  указываются значения при базовых случаях и от меньших базовых значений мы идём в сторону нужного значения функции, записывая в кеш полученные значения функции.
В этом случае мы так же можем при определённых условиях избавиться от кеша, заменяя базовые значения на вновь вычисленные.



